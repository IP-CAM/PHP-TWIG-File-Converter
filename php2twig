#!/usr/bin/env php
<?php

$options = [
    'extension'     => '.tpl.php',
    'new_extension' => '.tpl.twig',
    'recursive'     => false,
];

// First we need to get some arguments
if ($argc > 1) {
    $files = [];
    $current_dir = getcwd();

    // Look for commonly found arguments
    $cargv = count($argv);
    for ($i = 1; $i <= $argc && $i <= $cargv - 1; $i++) {
        switch ($argv[$i]) {
            case '-h':
            case '--help':
                print <<<HELP
php2twig: Convert PHPTemplate files to twig

Usage:
  Provide a location to a file or directory as argument to convert all .tpl.php
  files.

Options:
  -h    Display this help
  -r    Recursive
  -e    Extension (default: .tpl.php)
  -ne   New extension (default: .tpl.twig)
  -v    Verbose

Examples:
  - ./php2twig -ne .html.twig **/*.tpl.php
  - ./php2twig -r 1 .

HELP;
                break;

            // Extension
            case '-e':
                if (!isset($argv[$i + 1])) {
                    die("You must provide an extension");
                }
                $options['extension'] = $argv[$i + 1];
                $i++;
                break;

            // New extension
            case '-ne':
                if (!isset($argv[$i + 1])) {
                    die("You must provide an extension");
                }
                $options['new_extension'] = $argv[$i + 1];
                $i++;
                break;

            // Recursive
            case '-r':
                $options['recursive'] = true;
                break;

            // Files
            default:
                if (!isset($argv[$i])) {
                    break 2;
                }

                // Treat locations
                $file = $argv[$i];
                if (is_file($file)) {
                    $files[] = $file;
                } else {
                    echo "$file is not a valid file path.\n";
                }
        }
    }

    // Treat files
    if (!empty($files)) {
        foreach ($files as $file) {
            $new_name = str_replace($options['extension'], $options['new_extension'], basename($file));
            echo "Converting $file to $new_name\n";
            $converted = convert_phptemplate(file_get_contents($file));
            file_put_contents(dirname($file).'/'.$new_name, $converted, FILE_TEXT);
        }
    }
} else {
    $str = file_get_contents('php://stdin');
    if ($str) {
        print convert_phptemplate($str);
    } else {
        die("No file or directory specified");
    }
}

/**
 * Function
 *
 * @param $str string
 * @return array
 */
function convert_phptemplate($str)
{
    $tokens = token_get_all($str);
    $output = '';
    $mapping = [
        T_ARRAY, // array()
        T_BREAK, // TODO 	break 	break",
        T_CASE, // , // TODO  	case 	switch",
        T_COMMENT, // "                  => '{# %s #}', // TODO or #, and /* */ 	comments",
        T_CONCAT_EQUAL, // "             => '', // TODO 	.= 	assignment operators",
        T_CONTINUE, // ", // TODO 	continue 	continue",
        T_CURLY_OPEN, // ", // TODO 	 	complex variable parsed syntax",
        T_DEFAULT, // ", // TODO 	default 	switch",
        T_DO, // ", // TODO 	do    do..while",
        T_DOLLAR_OPEN_CURLY_BRACES, // complex variable parsed syntax",
        T_ELSEIF, // elseif 	elseif",
        T_EMPTY, // empty    empty()",
        T_ENCAPSED_AND_WHITESPACE, // \" \$a\" 	constant part of string with variables",
        T_ENDSWITCH, // endswitch 	switch, alternative syntax",
        T_ENDWHILE, // endwhile 	while, alternative syntax",
        T_FOR, // for 	for",
        T_INCLUDE, // include() 	include",
        T_INCLUDE_ONCE, // include_once() 	include_once",
        T_NUM_STRING, // \"\$a[0]\" 	numeric array index inside string",
        T_REQUIRE, // require() 	require",
        T_REQUIRE_ONCE, // require_once() 	require_once",
        T_STRING_VARNAME, // \"$\{a 	complex variable parsed syntax",
        T_SWITCH, // switch 	switch",
    ];
    // LIFO list of end tags
    $nesting = [];
    $flags = [];
    while ($token = current($tokens)) {
        $index = key($tokens);
        if (is_array($token) /*&& in_array($token[0], $mapping)*/) {
            echo "Index $index, Line {$token[2]}: ", token_name($token[0]), "\t\t{$token[1]}", PHP_EOL;
        } else {
            echo "Index $index, $token", PHP_EOL;
        }
        if (is_array($token)) {
            $name = $token[0];
            $value = $token[1];

            if (isset($tokens[$index + 1])) {
                $i = $index;
                while (isset($tokens[$i + 1]) && $tokens[$i + 1][0] == T_WHITESPACE) {
                    $i++;
                }
                $next = $tokens[$i + 1];
                if (is_array($next)) {
                    if (in_array($next[0], [T_OR_EQUAL, T_PLUS_EQUAL, T_MUL_EQUAL, T_MINUS_EQUAL, T_MUL_EQUAL])) {
                        $output .= $value.' '.substr($token[1], 0, 1).' '.$value;
                        next($tokens);
                        continue;
                    } elseif ($next[0] == T_INC) {
                        $output .= "{% $value = $value + 1 %}";
                        next($tokens);
                        continue;
                    } elseif ($next[0] == T_DEC) {
                        $output .= "{% $value = $value - 1 %}";
                        next($tokens);
                        continue;
                    }
                }
            }

            if (in_array($name, [
                T_OR_EQUAL,
                T_PLUS_EQUAL,
                T_MUL_EQUAL,
                T_MINUS_EQUAL,
                T_ISSET,
                T_OPEN_TAG,
                T_DOC_COMMENT,
            ])) {
                // Ignore
            } elseif (in_array($name, [T_CLOSE_TAG, T_INLINE_HTML])) {
                $nest = array_pop($nesting);
                // Remove last space for filters
                if ($nest[0] == '|') {
                    $output = rtrim($output, ' ');
                }
                $output .= $nest;
                $output .= str_replace("?>", "", $value);
            } elseif (in_array($name, [
                T_WHITESPACE,
                T_LOGICAL_AND,
                T_LOGICAL_OR,
                T_CONSTANT_ENCAPSED_STRING,
                T_LNUMBER,
                T_DNUMBER,
                T_IS_GREATER_OR_EQUAL,
                T_IS_SMALLER_OR_EQUAL,
            ])) {
                $output .= $value;
            } elseif ($name == T_VARIABLE) {
                $output .= substr($value, 1);
            } elseif ($name == T_ECHO || $name == T_PRINT) {
                $output .= '{{';
                $nesting[] = '}}';
            } elseif ($name == T_STRING) {
                if ($value == 't') {
                    $nest = array_pop($nesting);
                    $nesting[] = '|t '.$nest;
                } elseif ($value == 'render') {
                    // Ignore
                } elseif (in_array('inside_object_method', $flags) && next($tokens) !== '(') {
                    $output .= $value;
                } else {
                    $output .= $value.'(';
                    $nesting[] = ')';
                    $flags[] = 'inside_func_call';
                    // TODO fire warning here
                }
                // TODO maybe handle theme() ?
            } elseif ($name == T_IS_EQUAL || $name == T_IS_IDENTICAL) {
                $output .= ' is ';
            } elseif ($name == T_IS_NOT_EQUAL || $name == T_IS_NOT_IDENTICAL) {
                $output .= ' is not ';
            } elseif ($name == T_BOOLEAN_AND) {
                $output .= ' and ';
            } elseif ($name == T_BOOLEAN_OR) {
                $output .= ' or ';
            } elseif ($name == T_IF) {
                $output .= '{% if';
                $nesting[] = '%}';
            } elseif ($name == T_ENDIF) {
                $output .= '{% endif %}';
            } elseif ($name == T_ENDFOR || $name == T_ENDFOREACH) {
                $output .= '{% endfor %}';
            } elseif ($name == T_ELSEIF) {
                $output .= '{% elseif ';
                $nesting[] = '%}';
            } elseif ($name == T_ELSE) {
                $output .= '{% else %} ';
            } elseif ($name == T_OBJECT_OPERATOR) {
                $flags[] = 'inside_object_method';
                $output .= '.';
            } elseif ($name == T_COMMENT) {
                if ($value[1] == '*') {
                    $value = preg_replace('@/\*(.+)\s+\*/@sU', '{# $1 #}', $value);
                    $value = preg_replace('@\s{3}\*\s@s', '', $value);
                    $output .= $value;
                } else {
                    $output .= "{# ";
                    prev($tokens);
                    $matches = null;
                    while (($token = next($tokens)) && is_array($token) && in_array($token[0], [T_WHITESPACE, T_COMMENT])) {
                        if ($token[0] == T_COMMENT) {
                            if (isset($matches[2])) {
                                $output .= "$matches[2]";
                            }
                            preg_match('@^//\s?(.*)(\s*)@', $token[1], $matches);
                            $output .= "$matches[1]";
                        }
                        else {
                            $matches[2] .= "$token[1]";
                        }
                    }
                    $output .= " #}".$matches[2];
                    prev($tokens);
                }
            } elseif ($name == T_FOREACH) {
                $output .= '{% for';
                while (!is_array($token) || !in_array($token[0], [T_VARIABLE, T_STRING])) {
                    $token = next($tokens);
                }
                $iterated = substr($token[1], 1);
                while (!is_array($token) || $token[0] !== T_AS) {
                    $token = next($tokens);
                }
                while (!is_array($token) || $token[0] !== T_VARIABLE) {
                    $token = next($tokens);
                }
                $index_name = substr($token[1], 1);

                // Try to find value in next four tokens
                $i = 6;
                while (($token = next($tokens)) && $i) {
                    if (is_array($token) && $token[0] == T_VARIABLE) {
                        $value = substr($token[1], 1);
                        $output .= " $index_name, $value in $iterated %}";
                        break;
                    }
                    $i--;
                }
                if (!$i) {
                    $output .= " $index_name in $iterated %}";
                    // We've got too far, go back a bit
                    prev($tokens);
                    prev($tokens);
                    prev($tokens);
                    prev($tokens);
                }

            } else {
                // unsupported
                echo "UNSUPPORTED ".token_name($token[0])."\n";
            }
        } else {
            switch ($token) {
                case ';':
                    if (in_array('inside_func_call', $flags)) {
                        $output .= array_pop($nesting);
                        unset($flags[array_search('inside_func_call', $flags)]);
                    }
                    break;
                case ':':
                    if (in_array('inside_ternary', $flags)) {
                        $output .= $token;
                        unset($flags[array_search('inside_ternary', $flags)]);
                    }
                    break;
                case '(':
                case ')':
                case '{':
                case '}':
                case ']':
                    break;
                case '[':
                    $next = next($tokens);
                    if (is_array($next) && $next[0] == T_CONSTANT_ENCAPSED_STRING) {
                        $output .= '.'.substr($next[1], 1, -1);
                    } elseif (is_array($next) && $next[0] == T_VARIABLE) {
                        $output .= '.'.substr($next[1], 1);
                    } elseif (is_array($next) && $next[0] == T_LNUMBER) {
                        $output .= '.'.$next[1];
                    } elseif (is_array($next)) {
                        die("Unsupported array/object traversing with ".token_name($next[0]));
                    } else {
                        $output .= "[$next]";
                    }
                    break;
                case '.':
                    $output .= '~';
                    break;
                case '?':
                    $flags[] = 'inside_ternary';
                    $output .= $token;
                    break;
                case ',':
                case '%':
                case '*':
                case '/':
                case '+':
                case '-':
                    $output .= $token;
                    break;
            }
        }
        next($tokens);
    }

    echo $str, $output, "\n";
    return $output;
}
